/**
 * @fileoverview This file is generated by the Angular 2 template compiler.
 * Do not edit.
 * @suppress {suspiciousCode,uselessCode,missingProperties}
 */
/* tslint:disable */
import * as import0 from '@angular/core/src/linker/ng_module_factory';
import * as import1 from '@angular/material/tooltip/tooltip';
import * as import2 from '@angular/material/core/portal/portal-directives';
import * as import3 from '@angular/material/core/overlay/overlay-directives';
import * as import4 from '@angular/material/core/compatibility/default-mode';
import * as import6 from '@angular/core/src/change_detection/change_detection';
import * as import7 from '@angular/core/src/linker/view';
import * as import8 from '@angular/core/src/linker/view_utils';
import * as import10 from '@angular/core/src/metadata/view';
import * as import11 from '@angular/core/src/linker/view_type';
import * as import12 from '@angular/core/src/linker/component_factory';
import * as import13 from '@angular/material/core/rtl/dir';
import * as import14 from './tooltip.css.shim';
import * as import15 from '@angular/core/src/animation/animation_transition';
import * as import16 from '@angular/core/src/animation/animation_sequence_player';
import * as import17 from '@angular/core/src/animation/animation_styles';
import * as import18 from '@angular/core/src/animation/animation_style_util';
import * as import19 from '@angular/core/src/animation/animation_keyframe';
import * as import20 from '@angular/core/src/animation/animation_player';
import * as import21 from '@angular/core/src/security';
class MdTooltipModuleInjector extends import0.NgModuleInjector {
    constructor(parent) {
        super(parent, [TooltipComponentNgFactory], []);
    }
    get _MATERIAL_COMPATIBILITY_MODE_4() {
        if ((this.__MATERIAL_COMPATIBILITY_MODE_4 == null)) {
            (this.__MATERIAL_COMPATIBILITY_MODE_4 = false);
        }
        return this.__MATERIAL_COMPATIBILITY_MODE_4;
    }
    createInternal() {
        this._PortalModule_0 = new import2.PortalModule();
        this._OverlayModule_1 = new import3.OverlayModule();
        this._DefaultStyleCompatibilityModeModule_2 = new import4.DefaultStyleCompatibilityModeModule();
        this._MdTooltipModule_3 = new import1.MdTooltipModule();
        return this._MdTooltipModule_3;
    }
    getInternal(token, notFoundResult) {
        if ((token === import2.PortalModule)) {
            return this._PortalModule_0;
        }
        if ((token === import3.OverlayModule)) {
            return this._OverlayModule_1;
        }
        if ((token === import4.DefaultStyleCompatibilityModeModule)) {
            return this._DefaultStyleCompatibilityModeModule_2;
        }
        if ((token === import1.MdTooltipModule)) {
            return this._MdTooltipModule_3;
        }
        if ((token === import4.MATERIAL_COMPATIBILITY_MODE)) {
            return this._MATERIAL_COMPATIBILITY_MODE_4;
        }
        return notFoundResult;
    }
    destroyInternal() {
    }
}
export const MdTooltipModuleNgFactory = new import0.NgModuleFactory(MdTooltipModuleInjector, import1.MdTooltipModule);
export class Wrapper_MdTooltip {
    constructor(p0, p1, p2, p3, p4) {
        this._changed = false;
        this.context = new import1.MdTooltip(p0, p1, p2, p3, p4);
        this._expr_0 = import6.UNINITIALIZED;
        this._expr_1 = import6.UNINITIALIZED;
    }
    ngOnDetach(view, componentView, el) {
    }
    ngOnDestroy() {
        this.context.ngOnDestroy();
    }
    check_position(currValue, throwOnChange, forceUpdate) {
        if ((forceUpdate || import8.checkBinding(throwOnChange, this._expr_0, currValue))) {
            this._changed = true;
            this.context.position = currValue;
            this._expr_0 = currValue;
        }
    }
    check_message(currValue, throwOnChange, forceUpdate) {
        if ((forceUpdate || import8.checkBinding(throwOnChange, this._expr_1, currValue))) {
            this._changed = true;
            this.context.message = currValue;
            this._expr_1 = currValue;
        }
    }
    ngDoCheck(view, el, throwOnChange) {
        var changed = this._changed;
        this._changed = false;
        return changed;
    }
    checkHost(view, componentView, el, throwOnChange) {
    }
    handleEvent(eventName, $event) {
        var result = true;
        if ((eventName == 'longpress')) {
            const pd_sub_0 = (this.context.show() !== false);
            result = (pd_sub_0 && result);
        }
        if ((eventName == 'touchend')) {
            const pd_sub_1 = (this.context.hide(1500) !== false);
            result = (pd_sub_1 && result);
        }
        if ((eventName == 'mouseenter')) {
            const pd_sub_2 = (this.context.show() !== false);
            result = (pd_sub_2 && result);
        }
        if ((eventName == 'mouseleave')) {
            const pd_sub_3 = (this.context.hide() !== false);
            result = (pd_sub_3 && result);
        }
        return result;
    }
    subscribe(view, _eventHandler) {
        this._eventHandler = _eventHandler;
    }
}
export class Wrapper_TooltipComponent {
    constructor(p0) {
        this._changed = false;
        this.context = new import1.TooltipComponent(p0);
    }
    ngOnDetach(view, componentView, el) {
    }
    ngOnDestroy() {
    }
    ngDoCheck(view, el, throwOnChange) {
        var changed = this._changed;
        this._changed = false;
        return changed;
    }
    checkHost(view, componentView, el, throwOnChange) {
    }
    handleEvent(eventName, $event) {
        var result = true;
        if ((eventName == 'body:click')) {
            const pd_sub_0 = (this.context._handleBodyInteraction() !== false);
            result = (pd_sub_0 && result);
        }
        return result;
    }
    subscribe(view, _eventHandler) {
        this._eventHandler = _eventHandler;
    }
}
var renderType_TooltipComponent_Host = import8.createRenderComponentType('', 0, import10.ViewEncapsulation.None, [], {});
class View_TooltipComponent_Host0 extends import7.AppView {
    constructor(viewUtils, parentView, parentIndex, parentElement) {
        super(View_TooltipComponent_Host0, renderType_TooltipComponent_Host, import11.ViewType.HOST, viewUtils, parentView, parentIndex, parentElement, import6.ChangeDetectorStatus.CheckAlways);
    }
    createInternal(rootSelector) {
        this._el_0 = import8.selectOrCreateRenderHostElement(this.renderer, 'md-tooltip-component', import8.EMPTY_INLINE_ARRAY, rootSelector, null);
        this.compView_0 = new View_TooltipComponent0(this.viewUtils, this, 0, this._el_0);
        this._TooltipComponent_0_3 = new Wrapper_TooltipComponent(this.injectorGet(import13.Dir, this.parentIndex, null));
        this.compView_0.create(this._TooltipComponent_0_3.context);
        var disposable_0 = import8.subscribeToRenderElement(this, this._el_0, new import8.InlineArray2(2, 'click', 'body'), this.eventHandler(this.handleEvent_0));
        this.init(this._el_0, (this.renderer.directRenderer ? null : [this._el_0]), [disposable_0]);
        return new import12.ComponentRef_(0, this, this._el_0, this._TooltipComponent_0_3.context);
    }
    injectorGetInternal(token, requestNodeIndex, notFoundResult) {
        if (((token === import1.TooltipComponent) && (0 === requestNodeIndex))) {
            return this._TooltipComponent_0_3.context;
        }
        return notFoundResult;
    }
    detectChangesInternal(throwOnChange) {
        this._TooltipComponent_0_3.ngDoCheck(this, this._el_0, throwOnChange);
        this.compView_0.detectChanges(throwOnChange);
    }
    destroyInternal() {
        this.compView_0.destroy();
    }
    visitRootNodesInternal(cb, ctx) {
        cb(this._el_0, ctx);
    }
    handleEvent_0(eventName, $event) {
        this.compView_0.markPathToRootAsCheckOnce();
        var result = true;
        result = (this._TooltipComponent_0_3.handleEvent(eventName, $event) && result);
        return result;
    }
}
export const TooltipComponentNgFactory = new import12.ComponentFactory('md-tooltip-component, mat-tooltip-component', View_TooltipComponent_Host0, import1.TooltipComponent);
const styles_TooltipComponent = [import14.styles];
var TooltipComponent_state_states = {
    void: { transform: 'scale(0)' },
    visible: { transform: 'scale(1)' },
    hidden: { transform: 'scale(0)' },
    '*': {}
};
function TooltipComponent_state_factory(view, element, currentState, nextState) {
    var previousPlayers = view.animationContext.getAnimationPlayers(element, 'state', (nextState == 'void'));
    var collectedStyles = {};
    var player = null;
    var totalTime = 0;
    var defaultStateStyles = TooltipComponent_state_states['*'];
    var startStateStyles = TooltipComponent_state_states[currentState];
    if ((startStateStyles == null)) {
        (startStateStyles = defaultStateStyles);
    }
    var endStateStyles = TooltipComponent_state_states[nextState];
    if ((endStateStyles == null)) {
        (endStateStyles = defaultStateStyles);
    }
    if (((player == null) && (true && (nextState == 'visible')))) {
        player = new import16.AnimationSequencePlayer([view.renderer.animate(element, new import17.AnimationStyles(import18.collectAndResolveStyles(collectedStyles, [startStateStyles])), import18.balanceAnimationKeyframes(collectedStyles, endStateStyles, [
                new import19.AnimationKeyframe(0, new import17.AnimationStyles(import18.collectAndResolveStyles(collectedStyles, [{}]))),
                new import19.AnimationKeyframe(1, new import17.AnimationStyles(import18.collectAndResolveStyles(collectedStyles, [{}])))
            ]), 150, 0, 'cubic-bezier(0.0, 0.0, 0.2, 1)', previousPlayers)]);
        totalTime = 150;
    }
    if (((player == null) && (true && (nextState == 'hidden')))) {
        player = new import16.AnimationSequencePlayer([view.renderer.animate(element, new import17.AnimationStyles(import18.collectAndResolveStyles(collectedStyles, [startStateStyles])), import18.balanceAnimationKeyframes(collectedStyles, endStateStyles, [
                new import19.AnimationKeyframe(0, new import17.AnimationStyles(import18.collectAndResolveStyles(collectedStyles, [{}]))),
                new import19.AnimationKeyframe(1, new import17.AnimationStyles(import18.collectAndResolveStyles(collectedStyles, [{}])))
            ]), 150, 0, 'cubic-bezier(0.4, 0.0, 1, 1)', previousPlayers)]);
        totalTime = 150;
    }
    if ((player == null)) {
        (player = new import20.NoOpAnimationPlayer());
    }
    player.onDone(() => {
        player.destroy();
        import18.renderStyles(element, view.renderer, import18.prepareFinalAnimationStyles(startStateStyles, endStateStyles));
    });
    new import16.AnimationSequencePlayer(previousPlayers).destroy();
    import18.renderStyles(element, view.renderer, import18.clearStyles(startStateStyles));
    view.animationContext.queueAnimation(element, 'state', player);
    return new import15.AnimationTransition(player, currentState, nextState, totalTime);
}
var renderType_TooltipComponent = import8.createRenderComponentType('', 0, import10.ViewEncapsulation.Emulated, styles_TooltipComponent, { state: TooltipComponent_state_factory });
export class View_TooltipComponent0 extends import7.AppView {
    constructor(viewUtils, parentView, parentIndex, parentElement) {
        super(View_TooltipComponent0, renderType_TooltipComponent, import11.ViewType.COMPONENT, viewUtils, parentView, parentIndex, parentElement, import6.ChangeDetectorStatus.CheckAlways);
        this._expr_2 = import6.UNINITIALIZED;
        this._expr_3 = import6.UNINITIALIZED;
        this._expr_4 = import6.UNINITIALIZED;
    }
    createInternal(rootSelector) {
        const parentRenderNode = this.renderer.createViewRoot(this.parentElement);
        this._el_0 = import8.createRenderElement(this.renderer, parentRenderNode, 'div', new import8.InlineArray2(2, 'class', 'md-tooltip'), null);
        this._text_1 = this.renderer.createText(this._el_0, '', null);
        this.init(null, (this.renderer.directRenderer ? null : [
            this._el_0,
            this._text_1
        ]), null);
        return null;
    }
    detectChangesInternal(throwOnChange) {
        const currVal_3 = this.context._visibility;
        if (import8.checkBinding(throwOnChange, this._expr_3, currVal_3)) {
            var animationTransition_state = this.componentType.animations['state'](this, this._el_0, ((this._expr_3 == import6.UNINITIALIZED) ? 'void' : this._expr_3), ((currVal_3 == import6.UNINITIALIZED) ? 'void' : currVal_3));
            animationTransition_state.onStart(this.handleEvent_0.bind(this).bind(this, '@state.start'));
            animationTransition_state.onDone(this.handleEvent_0.bind(this).bind(this, '@state.done'));
            this._expr_3 = currVal_3;
        }
        const currVal_2 = this.context._transformOrigin;
        if (import8.checkBinding(throwOnChange, this._expr_2, currVal_2)) {
            this.renderer.setElementStyle(this._el_0, 'transform-origin', ((this.viewUtils.sanitizer.sanitize(import21.SecurityContext.STYLE, currVal_2) == null) ? null : this.viewUtils.sanitizer.sanitize(import21.SecurityContext.STYLE, currVal_2).toString()));
            this._expr_2 = currVal_2;
        }
        const currVal_4 = import8.inlineInterpolate(1, '\n  ', this.context.message, '\n');
        if (import8.checkBinding(throwOnChange, this._expr_4, currVal_4)) {
            this.renderer.setText(this._text_1, currVal_4);
            this._expr_4 = currVal_4;
        }
    }
    detachInternal() {
        var animationTransition_state = this.componentType.animations['state'](this, this._el_0, this._expr_3, 'void');
        animationTransition_state.onStart(this.handleEvent_0.bind(this).bind(this, '@state.start'));
        animationTransition_state.onDone(this.handleEvent_0.bind(this).bind(this, '@state.done'));
    }
    handleEvent_0(eventName, $event) {
        this.markPathToRootAsCheckOnce();
        var result = true;
        if ((eventName == '@state.done')) {
            const pd_sub_0 = (this.context._afterVisibilityAnimation($event) !== false);
            result = (pd_sub_0 && result);
        }
        return result;
    }
}
//# sourceMappingURL=tooltip.ngfactory.js.map